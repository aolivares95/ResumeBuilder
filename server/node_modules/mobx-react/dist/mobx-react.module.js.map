{"version":3,"file":"mobx-react.module.js","sources":["../src/utils/utils.js","../src/observerClass.js","../src/observer.js","../src/Provider.js","../src/inject.js","../src/disposeOnUnmount.js","../src/propTypes.js","../src/index.js"],"sourcesContent":["let symbolId = 0\nfunction createSymbol(name) {\n    if (typeof Symbol === \"function\") {\n        return Symbol(name)\n    }\n    const symbol = `__$mobx-react ${name} (${symbolId})`\n    symbolId++\n    return symbol\n}\n\nconst createdSymbols = {}\nexport function newSymbol(name) {\n    if (!createdSymbols[name]) {\n        createdSymbols[name] = createSymbol(name)\n    }\n    return createdSymbols[name]\n}\n\nexport function shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base, target) {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))\n    Object.getOwnPropertyNames(base).forEach(key => {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key))\n        }\n    })\n}\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nexport function setHiddenProp(target, prop, value) {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nconst mobxMixins = newSymbol(\"patchMixins\")\nconst mobxPatchedDefinition = newSymbol(\"patchedDefinition\")\n\nfunction getMixins(target, methodName) {\n    const mixins = (target[mobxMixins] = target[mobxMixins] || {})\n    const methodMixins = (mixins[methodName] = mixins[methodName] || {})\n    methodMixins.locks = methodMixins.locks || 0\n    methodMixins.methods = methodMixins.methods || []\n    return methodMixins\n}\n\nfunction wrapper(realMethod, mixins, ...args) {\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++\n\n    try {\n        let retVal\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args)\n        }\n\n        return retVal\n    } finally {\n        mixins.locks--\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(mx => {\n                mx.apply(this, args)\n            })\n        }\n    }\n}\n\nfunction wrapFunction(realMethod, mixins) {\n    const fn = function(...args) {\n        wrapper.call(this, realMethod, mixins, ...args)\n    }\n    return fn\n}\n\nexport function patch(target, methodName, mixinMethod) {\n    const mixins = getMixins(target, methodName)\n\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod)\n    }\n\n    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return\n    }\n\n    const originalMethod = target[methodName]\n    const newDefinition = createDefinition(\n        target,\n        methodName,\n        oldDefinition ? oldDefinition.enumerable : undefined,\n        mixins,\n        originalMethod\n    )\n\n    Object.defineProperty(target, methodName, newDefinition)\n}\n\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n    let wrappedFunc = wrapFunction(originalMethod, mixins)\n\n    return {\n        [mobxPatchedDefinition]: true,\n        get: function() {\n            return wrappedFunc\n        },\n        set: function(value) {\n            if (this === target) {\n                wrappedFunc = wrapFunction(value, mixins)\n            } else {\n                // when it is an instance of the prototype/a child prototype patch that particular case again separately\n                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n                // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n                // as the method for the instance\n                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)\n                Object.defineProperty(this, methodName, newDefinition)\n            }\n        },\n        configurable: true,\n        enumerable: enumerable\n    }\n}\n","import { PureComponent, Component } from \"react\"\nimport { createAtom, _allowStateChanges, Reaction, $mobx } from \"mobx\"\nimport { isUsingStaticRendering } from \"mobx-react-lite\"\n\nimport { newSymbol, shallowEqual, setHiddenProp, patch } from \"./utils/utils\"\n\nconst mobxAdminProperty = $mobx || \"$mobx\"\nconst mobxIsUnmounted = newSymbol(\"isUnmounted\")\nconst skipRenderKey = newSymbol(\"skipRender\")\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\n\nexport function makeClassComponentObserver(componentClass) {\n    const target = componentClass.prototype\n    if (target.componentWillReact)\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    if (componentClass.__proto__ !== PureComponent) {\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\n        else if (target.shouldComponentUpdate !== observerSCU)\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n    }\n\n    // this.props and this.state are made observable, just to make sure @computed fields that\n    // are defined inside the component, and which rely on state or props, re-compute if state or props change\n    // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n    // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n    makeObservableProp(target, \"props\")\n    makeObservableProp(target, \"state\")\n\n    const baseRender = target.render\n    target.render = function() {\n        return makeComponentReactive.call(this, baseRender)\n    }\n    patch(target, \"componentWillUnmount\", function() {\n        if (isUsingStaticRendering() === true) return\n        this.render[mobxAdminProperty] && this.render[mobxAdminProperty].dispose()\n        this[mobxIsUnmounted] = true\n    })\n    return componentClass\n}\n\nfunction makeComponentReactive(render) {\n    if (isUsingStaticRendering() === true) return render.call(this)\n\n    /**\n     * If props are shallowly modified, react will render anyway,\n     * so atom.reportChanged() should not result in yet another re-render\n     */\n    setHiddenProp(this, skipRenderKey, false)\n    /**\n     * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n     * so detect these changes\n     */\n    setHiddenProp(this, isForcingUpdateKey, false)\n\n    // Generate friendly name for debugging\n    const initialName =\n        this.displayName ||\n        this.name ||\n        (this.constructor && (this.constructor.displayName || this.constructor.name)) ||\n        \"<component>\"\n    const baseRender = render.bind(this)\n\n    let isRenderingPending = false\n\n    const reaction = new Reaction(`${initialName}.render()`, () => {\n        if (!isRenderingPending) {\n            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n            // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n            // See #85 / Pull #44\n            isRenderingPending = true\n            if (this[mobxIsUnmounted] !== true) {\n                let hasError = true\n                try {\n                    setHiddenProp(this, isForcingUpdateKey, true)\n                    if (!this[skipRenderKey]) Component.prototype.forceUpdate.call(this)\n                    hasError = false\n                } finally {\n                    setHiddenProp(this, isForcingUpdateKey, false)\n                    if (hasError) reaction.dispose()\n                }\n            }\n        }\n    })\n    reaction.reactComponent = this\n    reactiveRender[mobxAdminProperty] = reaction\n    this.render = reactiveRender\n\n    function reactiveRender() {\n        isRenderingPending = false\n        let exception = undefined\n        let rendering = undefined\n        reaction.track(() => {\n            try {\n                rendering = _allowStateChanges(false, baseRender)\n            } catch (e) {\n                exception = e\n            }\n        })\n        if (exception) {\n            throw exception\n        }\n        return rendering\n    }\n\n    return reactiveRender.call(this)\n}\n\nfunction observerSCU(nextProps, nextState) {\n    if (isUsingStaticRendering()) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction makeObservableProp(target, propName) {\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\n    function getAtom() {\n        if (!this[atomHolderKey]) {\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\n        }\n        return this[atomHolderKey]\n    }\n    Object.defineProperty(target, propName, {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            getAtom.call(this).reportObserved()\n            return this[valueHolderKey]\n        },\n        set: function set(v) {\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n                setHiddenProp(this, valueHolderKey, v)\n                setHiddenProp(this, skipRenderKey, true)\n                getAtom.call(this).reportChanged()\n                setHiddenProp(this, skipRenderKey, false)\n            } else {\n                setHiddenProp(this, valueHolderKey, v)\n            }\n        }\n    })\n}\n","/* eslint-disable react/display-name */\nimport React, { Component, forwardRef, memo } from \"react\"\nimport { observer as observerLite, Observer } from \"mobx-react-lite\"\n\nimport { makeClassComponentObserver } from \"./observerClass\"\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef(() => {})[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo(() => {})[\"$$typeof\"]\n\n/**\n * Observer function / decorator\n */\nexport function observer(componentClass) {\n    if (componentClass.isMobxInjector === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"\n        )\n    }\n\n    if (ReactMemoSymbol && componentClass[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            \"Mobx observer: You are trying to use 'observer' on function component wrapped to either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\"\n        )\n    }\n\n    // Unwrap forward refs into `<Observer>` component\n    // we need to unwrap the render, because it is the inner render that needs to be tracked,\n    // not the ForwardRef HoC\n    if (ReactForwardRefSymbol && componentClass[\"$$typeof\"] === ReactForwardRefSymbol) {\n        const baseRender = componentClass.render\n        if (typeof baseRender !== \"function\")\n            throw new Error(\"render property of ForwardRef was not a function\")\n        return forwardRef(function ObserverForwardRef() {\n            return <Observer>{() => baseRender.apply(undefined, arguments)}</Observer>\n        })\n    }\n\n    // Function component\n    if (\n        typeof componentClass === \"function\" &&\n        (!componentClass.prototype || !componentClass.prototype.render) &&\n        !componentClass.isReactClass &&\n        !Object.prototype.isPrototypeOf.call(Component, componentClass)\n    ) {\n        return observerLite(componentClass)\n    }\n\n    return makeClassComponentObserver(componentClass)\n}\n","/* eslint-disable react/prop-types */\nimport React from \"react\"\nimport { shallowEqual } from \"./utils/utils\"\n\nexport const MobXProviderContext = React.createContext({})\n\nexport function Provider({ children, ...stores }) {\n    const parentValue = React.useContext(MobXProviderContext)\n    const value = React.useRef({\n        ...parentValue,\n        ...stores\n    }).current\n\n    if (process.env.NODE_ENV !== \"production\") {\n        const newValue = { ...value, ...stores } // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) {\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\"\n            )\n        }\n    }\n\n    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>\n}\n\nProvider.displayName = \"MobXProvider\"\n","import React, { createElement } from \"react\"\nimport { observer } from \"./observer\"\nimport { copyStaticProperties } from \"./utils/utils\"\nimport { MobXProviderContext } from \"./Provider\"\n\n/**\n * Store Injection\n */\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n    // Support forward refs\n    let Injector = React.forwardRef((props, ref) => {\n        const newProps = { ...props }\n        const context = React.useContext(MobXProviderContext)\n        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {})\n\n        if (ref) {\n            newProps.ref = ref\n        }\n\n        return createElement(component, newProps)\n    })\n\n    if (makeReactive) Injector = observer(Injector)\n    Injector.isMobxInjector = true // assigned late to suppress observer warning\n\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, Injector)\n    Injector.wrappedComponent = component\n    Injector.displayName = getInjectName(component, injectNames)\n    return Injector\n}\n\nfunction getInjectName(component, injectNames) {\n    let displayName\n    const componentName =\n        component.displayName ||\n        component.name ||\n        (component.constructor && component.constructor.name) ||\n        \"Component\"\n    if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\"\n    else displayName = \"inject(\" + componentName + \")\"\n    return displayName\n}\n\nfunction grabStoresByName(storeNames) {\n    return function(baseStores, nextProps) {\n        storeNames.forEach(function(storeName) {\n            if (\n                storeName in nextProps // prefer props over stores\n            )\n                return\n            if (!(storeName in baseStores))\n                throw new Error(\n                    \"MobX injector: Store '\" +\n                        storeName +\n                        \"' is not available! Make sure it is provided by some Provider\"\n                )\n            nextProps[storeName] = baseStores[storeName]\n        })\n        return nextProps\n    }\n}\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nexport function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames) {\n    let grabStoresFn\n    if (typeof arguments[0] === \"function\") {\n        grabStoresFn = arguments[0]\n        return componentClass =>\n            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)\n    } else {\n        return componentClass =>\n            createStoreInjector(\n                grabStoresByName(storeNames),\n                componentClass,\n                storeNames.join(\"-\"),\n                false\n            )\n    }\n}\n","import * as React from \"react\"\nimport { patch, newSymbol } from \"./utils/utils\"\n\nconst protoStoreKey = newSymbol(\"disposeOnUnmountProto\")\nconst instStoreKey = newSymbol(\"disposeOnUnmountInst\")\n\nfunction runDisposersOnWillUnmount() {\n    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop)) prop.map(f => f())\n            else prop()\n        }\n    })\n}\n\nexport function disposeOnUnmount(target, propertyKeyOrFunction) {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    const c = Object.getPrototypeOf(target).constructor || Object.getPrototypeOf(target.constructor)\n    const c2 = Object.getPrototypeOf(target.constructor)\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (\n        typeof propertyKeyOrFunction !== \"string\" &&\n        typeof propertyKeyOrFunction !== \"function\" &&\n        !Array.isArray(propertyKeyOrFunction)\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    const isDecorator = typeof propertyKeyOrFunction === \"string\"\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]\n    const store = isDecorator\n        ? // decorators are added to the prototype store\n          target[protoStoreKey] || (target[protoStoreKey] = [])\n        : // functions are added to the instance store\n          target[instStoreKey] || (target[instStoreKey] = [])\n\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount)\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\n\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validate) {\n    function checkType(\n        isRequired,\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            componentName = componentName || \"<<anonymous>>\"\n            propFullName = propFullName || propName\n            if (props[propName] == null) {\n                if (isRequired) {\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\n                    return new Error(\n                        \"The \" +\n                            location +\n                            \" `\" +\n                            propFullName +\n                            \"` is marked as required \" +\n                            \"in `\" +\n                            componentName +\n                            \"`, but its value is `\" +\n                            actual +\n                            \"`.\"\n                    )\n                }\n                return null\n            } else {\n                return validate(props, propName, componentName, location, propFullName, ...rest)\n            }\n        })\n    }\n\n    const chainedCheckType = checkType.bind(null, false)\n    chainedCheckType.isRequired = checkType.bind(null, true)\n    return chainedCheckType\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true\n    }\n\n    return false\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    const propType = typeof propValue\n    if (Array.isArray(propValue)) {\n        return \"array\"\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\"\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\"\n    }\n    return propType\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    const propType = getPropType(propValue)\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\"\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\"\n        }\n    }\n    return propType\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName\n    ) {\n        return untracked(() => {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\n            }\n            let mobxChecker\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray\n                    break\n                case \"Object\":\n                    mobxChecker = isObservableObject\n                    break\n                case \"Map\":\n                    mobxChecker = isObservableMap\n                    break\n                default:\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\n            }\n            const propValue = props[propName]\n            if (!mobxChecker(propValue)) {\n                const preciseType = getPreciseType(propValue)\n                const nativeTypeExpectationMessage = allowNativeType\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\n                    : \"\"\n                return new Error(\n                    \"Invalid prop `\" +\n                        propFullName +\n                        \"` of type `\" +\n                        preciseType +\n                        \"` supplied to\" +\n                        \" `\" +\n                        componentName +\n                        \"`, expected `mobx.Observable\" +\n                        mobxType +\n                        \"`\" +\n                        nativeTypeExpectationMessage +\n                        \".\"\n                )\n            }\n            return null\n        })\n    })\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\n                    \"Property `\" +\n                        propFullName +\n                        \"` of component `\" +\n                        componentName +\n                        \"` has \" +\n                        \"invalid PropType notation.\"\n                )\n            }\n            let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\n                props,\n                propName,\n                componentName\n            )\n            if (error instanceof Error) return error\n            const propValue = props[propName]\n            for (let i = 0; i < propValue.length; i++) {\n                error = typeChecker(\n                    propValue,\n                    i,\n                    componentName,\n                    location,\n                    propFullName + \"[\" + i + \"]\",\n                    ...rest\n                )\n                if (error instanceof Error) return error\n            }\n            return null\n        })\n    })\n}\n\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\n\nexport const PropTypes = {\n    observableArray,\n    observableArrayOf,\n    observableMap,\n    observableObject,\n    arrayOrObservableArray,\n    arrayOrObservableArrayOf,\n    objectOrObservableObject\n}\n","import { observable, configure } from \"mobx\"\nimport { Component } from \"react\"\nimport { unstable_batchedUpdates as rdBatched } from \"react-dom\"\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\")\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\")\n\nif (typeof rdBatched === \"function\") configure({ reactionScheduler: rdBatched })\n\nexport {\n    Observer,\n    useObserver,\n    useAsObservableSource,\n    useLocalStore,\n    isUsingStaticRendering,\n    useStaticRendering\n} from \"mobx-react-lite\"\n\nexport { observer } from \"./observer\"\n\nexport { Provider, MobXProviderContext } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\n"],"names":["let","symbolId","createdSymbols","newSymbol","name","Symbol","symbol","createSymbol","shallowEqual","objA","objB","is","keysA","Object","keys","keysB","length","i","hasOwnProperty","call","x","y","const","hoistBlackList","$$typeof","render","compare","type","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","setHiddenProp","target","prop","value","defineProperty","enumerable","configurable","writable","mobxMixins","mobxPatchedDefinition","wrapper","realMethod","locks","retVal","apply","this","args","methods","forEach","mx","wrapFunction","patch","methodName","mixinMethod","methodMixins","getMixins","indexOf","push","oldDefinition","getOwnPropertyDescriptor","newDefinition","createDefinition","originalMethod","wrappedFunc","get","set","undefined","mobxAdminProperty","$mobx","mobxIsUnmounted","skipRenderKey","isForcingUpdateKey","observerSCU","nextProps","nextState","isUsingStaticRendering","console","warn","state","props","makeObservableProp","propName","valueHolderKey","atomHolderKey","getAtom","createAtom","reportObserved","v","reportChanged","hasSymbol","for","ReactForwardRefSymbol","forwardRef","ReactMemoSymbol","memo","observer","componentClass","isMobxInjector","Error","baseRender","React","Observer","arguments","prototype","isReactClass","isPrototypeOf","Component","componentWillReact","__proto__","PureComponent","shouldComponentUpdate","initialName","displayName","constructor","bind","isRenderingPending","reaction","Reaction","hasError","forceUpdate","dispose","reactiveRender","exception","rendering","track","_allowStateChanges","e","reactComponent","makeClassComponentObserver","observerLite","MobXProviderContext","createContext","Provider","ref","parentValue","useContext","useRef","stores","current","process","env","NODE_ENV","children","createStoreInjector","grabStoresFn","component","injectNames","makeReactive","base","protoProps","Injector","newProps","context","assign","createElement","getOwnPropertyNames","getPrototypeOf","key","wrappedComponent","componentName","getInjectName","inject","storeNames","baseStores","storeName","grabStoresByName","join","protoStoreKey","instStoreKey","runDisposersOnWillUnmount","propKeyOrFunction","Array","isArray","map","f","disposeOnUnmount","propertyKeyOrFunction","fn","c","c2","componentWasAlreadyModified","createChainableTypeChecker","validate","checkType","isRequired","location","propFullName","untracked","rest","chainedCheckType","getPropType","propValue","propType","RegExp","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","Date","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","error","PropTypes","observable","rdBatched","configure","reactionScheduler"],"mappings":"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"}
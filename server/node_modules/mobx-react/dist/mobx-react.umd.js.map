{"version":3,"file":"mobx-react.umd.js","sources":["../src/utils/utils.js","../src/observerClass.js","../src/observer.js","../src/Provider.js","../src/inject.js","../src/disposeOnUnmount.js","../src/propTypes.js","../src/index.js"],"sourcesContent":["let symbolId = 0\nfunction createSymbol(name) {\n    if (typeof Symbol === \"function\") {\n        return Symbol(name)\n    }\n    const symbol = `__$mobx-react ${name} (${symbolId})`\n    symbolId++\n    return symbol\n}\n\nconst createdSymbols = {}\nexport function newSymbol(name) {\n    if (!createdSymbols[name]) {\n        createdSymbols[name] = createSymbol(name)\n    }\n    return createdSymbols[name]\n}\n\nexport function shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base, target) {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))\n    Object.getOwnPropertyNames(base).forEach(key => {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key))\n        }\n    })\n}\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nexport function setHiddenProp(target, prop, value) {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nconst mobxMixins = newSymbol(\"patchMixins\")\nconst mobxPatchedDefinition = newSymbol(\"patchedDefinition\")\n\nfunction getMixins(target, methodName) {\n    const mixins = (target[mobxMixins] = target[mobxMixins] || {})\n    const methodMixins = (mixins[methodName] = mixins[methodName] || {})\n    methodMixins.locks = methodMixins.locks || 0\n    methodMixins.methods = methodMixins.methods || []\n    return methodMixins\n}\n\nfunction wrapper(realMethod, mixins, ...args) {\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++\n\n    try {\n        let retVal\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args)\n        }\n\n        return retVal\n    } finally {\n        mixins.locks--\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(mx => {\n                mx.apply(this, args)\n            })\n        }\n    }\n}\n\nfunction wrapFunction(realMethod, mixins) {\n    const fn = function(...args) {\n        wrapper.call(this, realMethod, mixins, ...args)\n    }\n    return fn\n}\n\nexport function patch(target, methodName, mixinMethod) {\n    const mixins = getMixins(target, methodName)\n\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod)\n    }\n\n    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return\n    }\n\n    const originalMethod = target[methodName]\n    const newDefinition = createDefinition(\n        target,\n        methodName,\n        oldDefinition ? oldDefinition.enumerable : undefined,\n        mixins,\n        originalMethod\n    )\n\n    Object.defineProperty(target, methodName, newDefinition)\n}\n\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n    let wrappedFunc = wrapFunction(originalMethod, mixins)\n\n    return {\n        [mobxPatchedDefinition]: true,\n        get: function() {\n            return wrappedFunc\n        },\n        set: function(value) {\n            if (this === target) {\n                wrappedFunc = wrapFunction(value, mixins)\n            } else {\n                // when it is an instance of the prototype/a child prototype patch that particular case again separately\n                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n                // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n                // as the method for the instance\n                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)\n                Object.defineProperty(this, methodName, newDefinition)\n            }\n        },\n        configurable: true,\n        enumerable: enumerable\n    }\n}\n","import { PureComponent, Component } from \"react\"\nimport { createAtom, _allowStateChanges, Reaction, $mobx } from \"mobx\"\nimport { isUsingStaticRendering } from \"mobx-react-lite\"\n\nimport { newSymbol, shallowEqual, setHiddenProp, patch } from \"./utils/utils\"\n\nconst mobxAdminProperty = $mobx || \"$mobx\"\nconst mobxIsUnmounted = newSymbol(\"isUnmounted\")\nconst skipRenderKey = newSymbol(\"skipRender\")\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\n\nexport function makeClassComponentObserver(componentClass) {\n    const target = componentClass.prototype\n    if (target.componentWillReact)\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    if (componentClass.__proto__ !== PureComponent) {\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\n        else if (target.shouldComponentUpdate !== observerSCU)\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n    }\n\n    // this.props and this.state are made observable, just to make sure @computed fields that\n    // are defined inside the component, and which rely on state or props, re-compute if state or props change\n    // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n    // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n    makeObservableProp(target, \"props\")\n    makeObservableProp(target, \"state\")\n\n    const baseRender = target.render\n    target.render = function() {\n        return makeComponentReactive.call(this, baseRender)\n    }\n    patch(target, \"componentWillUnmount\", function() {\n        if (isUsingStaticRendering() === true) return\n        this.render[mobxAdminProperty] && this.render[mobxAdminProperty].dispose()\n        this[mobxIsUnmounted] = true\n    })\n    return componentClass\n}\n\nfunction makeComponentReactive(render) {\n    if (isUsingStaticRendering() === true) return render.call(this)\n\n    /**\n     * If props are shallowly modified, react will render anyway,\n     * so atom.reportChanged() should not result in yet another re-render\n     */\n    setHiddenProp(this, skipRenderKey, false)\n    /**\n     * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n     * so detect these changes\n     */\n    setHiddenProp(this, isForcingUpdateKey, false)\n\n    // Generate friendly name for debugging\n    const initialName =\n        this.displayName ||\n        this.name ||\n        (this.constructor && (this.constructor.displayName || this.constructor.name)) ||\n        \"<component>\"\n    const baseRender = render.bind(this)\n\n    let isRenderingPending = false\n\n    const reaction = new Reaction(`${initialName}.render()`, () => {\n        if (!isRenderingPending) {\n            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n            // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n            // See #85 / Pull #44\n            isRenderingPending = true\n            if (this[mobxIsUnmounted] !== true) {\n                let hasError = true\n                try {\n                    setHiddenProp(this, isForcingUpdateKey, true)\n                    if (!this[skipRenderKey]) Component.prototype.forceUpdate.call(this)\n                    hasError = false\n                } finally {\n                    setHiddenProp(this, isForcingUpdateKey, false)\n                    if (hasError) reaction.dispose()\n                }\n            }\n        }\n    })\n    reaction.reactComponent = this\n    reactiveRender[mobxAdminProperty] = reaction\n    this.render = reactiveRender\n\n    function reactiveRender() {\n        isRenderingPending = false\n        let exception = undefined\n        let rendering = undefined\n        reaction.track(() => {\n            try {\n                rendering = _allowStateChanges(false, baseRender)\n            } catch (e) {\n                exception = e\n            }\n        })\n        if (exception) {\n            throw exception\n        }\n        return rendering\n    }\n\n    return reactiveRender.call(this)\n}\n\nfunction observerSCU(nextProps, nextState) {\n    if (isUsingStaticRendering()) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction makeObservableProp(target, propName) {\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\n    function getAtom() {\n        if (!this[atomHolderKey]) {\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\n        }\n        return this[atomHolderKey]\n    }\n    Object.defineProperty(target, propName, {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            getAtom.call(this).reportObserved()\n            return this[valueHolderKey]\n        },\n        set: function set(v) {\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n                setHiddenProp(this, valueHolderKey, v)\n                setHiddenProp(this, skipRenderKey, true)\n                getAtom.call(this).reportChanged()\n                setHiddenProp(this, skipRenderKey, false)\n            } else {\n                setHiddenProp(this, valueHolderKey, v)\n            }\n        }\n    })\n}\n","/* eslint-disable react/display-name */\nimport React, { Component, forwardRef, memo } from \"react\"\nimport { observer as observerLite, Observer } from \"mobx-react-lite\"\n\nimport { makeClassComponentObserver } from \"./observerClass\"\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef(() => {})[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo(() => {})[\"$$typeof\"]\n\n/**\n * Observer function / decorator\n */\nexport function observer(componentClass) {\n    if (componentClass.isMobxInjector === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"\n        )\n    }\n\n    if (ReactMemoSymbol && componentClass[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            \"Mobx observer: You are trying to use 'observer' on function component wrapped to either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\"\n        )\n    }\n\n    // Unwrap forward refs into `<Observer>` component\n    // we need to unwrap the render, because it is the inner render that needs to be tracked,\n    // not the ForwardRef HoC\n    if (ReactForwardRefSymbol && componentClass[\"$$typeof\"] === ReactForwardRefSymbol) {\n        const baseRender = componentClass.render\n        if (typeof baseRender !== \"function\")\n            throw new Error(\"render property of ForwardRef was not a function\")\n        return forwardRef(function ObserverForwardRef() {\n            return <Observer>{() => baseRender.apply(undefined, arguments)}</Observer>\n        })\n    }\n\n    // Function component\n    if (\n        typeof componentClass === \"function\" &&\n        (!componentClass.prototype || !componentClass.prototype.render) &&\n        !componentClass.isReactClass &&\n        !Object.prototype.isPrototypeOf.call(Component, componentClass)\n    ) {\n        return observerLite(componentClass)\n    }\n\n    return makeClassComponentObserver(componentClass)\n}\n","/* eslint-disable react/prop-types */\nimport React from \"react\"\nimport { shallowEqual } from \"./utils/utils\"\n\nexport const MobXProviderContext = React.createContext({})\n\nexport function Provider({ children, ...stores }) {\n    const parentValue = React.useContext(MobXProviderContext)\n    const value = React.useRef({\n        ...parentValue,\n        ...stores\n    }).current\n\n    if (process.env.NODE_ENV !== \"production\") {\n        const newValue = { ...value, ...stores } // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) {\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\"\n            )\n        }\n    }\n\n    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>\n}\n\nProvider.displayName = \"MobXProvider\"\n","import React, { createElement } from \"react\"\nimport { observer } from \"./observer\"\nimport { copyStaticProperties } from \"./utils/utils\"\nimport { MobXProviderContext } from \"./Provider\"\n\n/**\n * Store Injection\n */\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n    // Support forward refs\n    let Injector = React.forwardRef((props, ref) => {\n        const newProps = { ...props }\n        const context = React.useContext(MobXProviderContext)\n        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {})\n\n        if (ref) {\n            newProps.ref = ref\n        }\n\n        return createElement(component, newProps)\n    })\n\n    if (makeReactive) Injector = observer(Injector)\n    Injector.isMobxInjector = true // assigned late to suppress observer warning\n\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, Injector)\n    Injector.wrappedComponent = component\n    Injector.displayName = getInjectName(component, injectNames)\n    return Injector\n}\n\nfunction getInjectName(component, injectNames) {\n    let displayName\n    const componentName =\n        component.displayName ||\n        component.name ||\n        (component.constructor && component.constructor.name) ||\n        \"Component\"\n    if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\"\n    else displayName = \"inject(\" + componentName + \")\"\n    return displayName\n}\n\nfunction grabStoresByName(storeNames) {\n    return function(baseStores, nextProps) {\n        storeNames.forEach(function(storeName) {\n            if (\n                storeName in nextProps // prefer props over stores\n            )\n                return\n            if (!(storeName in baseStores))\n                throw new Error(\n                    \"MobX injector: Store '\" +\n                        storeName +\n                        \"' is not available! Make sure it is provided by some Provider\"\n                )\n            nextProps[storeName] = baseStores[storeName]\n        })\n        return nextProps\n    }\n}\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nexport function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames) {\n    let grabStoresFn\n    if (typeof arguments[0] === \"function\") {\n        grabStoresFn = arguments[0]\n        return componentClass =>\n            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)\n    } else {\n        return componentClass =>\n            createStoreInjector(\n                grabStoresByName(storeNames),\n                componentClass,\n                storeNames.join(\"-\"),\n                false\n            )\n    }\n}\n","import * as React from \"react\"\nimport { patch, newSymbol } from \"./utils/utils\"\n\nconst protoStoreKey = newSymbol(\"disposeOnUnmountProto\")\nconst instStoreKey = newSymbol(\"disposeOnUnmountInst\")\n\nfunction runDisposersOnWillUnmount() {\n    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop)) prop.map(f => f())\n            else prop()\n        }\n    })\n}\n\nexport function disposeOnUnmount(target, propertyKeyOrFunction) {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    const c = Object.getPrototypeOf(target).constructor || Object.getPrototypeOf(target.constructor)\n    const c2 = Object.getPrototypeOf(target.constructor)\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (\n        typeof propertyKeyOrFunction !== \"string\" &&\n        typeof propertyKeyOrFunction !== \"function\" &&\n        !Array.isArray(propertyKeyOrFunction)\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    const isDecorator = typeof propertyKeyOrFunction === \"string\"\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]\n    const store = isDecorator\n        ? // decorators are added to the prototype store\n          target[protoStoreKey] || (target[protoStoreKey] = [])\n        : // functions are added to the instance store\n          target[instStoreKey] || (target[instStoreKey] = [])\n\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount)\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\n\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validate) {\n    function checkType(\n        isRequired,\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            componentName = componentName || \"<<anonymous>>\"\n            propFullName = propFullName || propName\n            if (props[propName] == null) {\n                if (isRequired) {\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\n                    return new Error(\n                        \"The \" +\n                            location +\n                            \" `\" +\n                            propFullName +\n                            \"` is marked as required \" +\n                            \"in `\" +\n                            componentName +\n                            \"`, but its value is `\" +\n                            actual +\n                            \"`.\"\n                    )\n                }\n                return null\n            } else {\n                return validate(props, propName, componentName, location, propFullName, ...rest)\n            }\n        })\n    }\n\n    const chainedCheckType = checkType.bind(null, false)\n    chainedCheckType.isRequired = checkType.bind(null, true)\n    return chainedCheckType\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true\n    }\n\n    return false\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue) {\n    const propType = typeof propValue\n    if (Array.isArray(propValue)) {\n        return \"array\"\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\"\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\"\n    }\n    return propType\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue) {\n    const propType = getPropType(propValue)\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\"\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\"\n        }\n    }\n    return propType\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName\n    ) {\n        return untracked(() => {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\n            }\n            let mobxChecker\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray\n                    break\n                case \"Object\":\n                    mobxChecker = isObservableObject\n                    break\n                case \"Map\":\n                    mobxChecker = isObservableMap\n                    break\n                default:\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\n            }\n            const propValue = props[propName]\n            if (!mobxChecker(propValue)) {\n                const preciseType = getPreciseType(propValue)\n                const nativeTypeExpectationMessage = allowNativeType\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\n                    : \"\"\n                return new Error(\n                    \"Invalid prop `\" +\n                        propFullName +\n                        \"` of type `\" +\n                        preciseType +\n                        \"` supplied to\" +\n                        \" `\" +\n                        componentName +\n                        \"`, expected `mobx.Observable\" +\n                        mobxType +\n                        \"`\" +\n                        nativeTypeExpectationMessage +\n                        \".\"\n                )\n            }\n            return null\n        })\n    })\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n    return createChainableTypeChecker(function(\n        props,\n        propName,\n        componentName,\n        location,\n        propFullName,\n        ...rest\n    ) {\n        return untracked(() => {\n            if (typeof typeChecker !== \"function\") {\n                return new Error(\n                    \"Property `\" +\n                        propFullName +\n                        \"` of component `\" +\n                        componentName +\n                        \"` has \" +\n                        \"invalid PropType notation.\"\n                )\n            }\n            let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\n                props,\n                propName,\n                componentName\n            )\n            if (error instanceof Error) return error\n            const propValue = props[propName]\n            for (let i = 0; i < propValue.length; i++) {\n                error = typeChecker(\n                    propValue,\n                    i,\n                    componentName,\n                    location,\n                    propFullName + \"[\" + i + \"]\",\n                    ...rest\n                )\n                if (error instanceof Error) return error\n            }\n            return null\n        })\n    })\n}\n\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\n\nexport const PropTypes = {\n    observableArray,\n    observableArrayOf,\n    observableMap,\n    observableObject,\n    arrayOrObservableArray,\n    arrayOrObservableArrayOf,\n    objectOrObservableObject\n}\n","import { observable, configure } from \"mobx\"\nimport { Component } from \"react\"\nimport { unstable_batchedUpdates as rdBatched } from \"react-dom\"\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\")\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\")\n\nif (typeof rdBatched === \"function\") configure({ reactionScheduler: rdBatched })\n\nexport {\n    Observer,\n    useObserver,\n    useAsObservableSource,\n    useLocalStore,\n    isUsingStaticRendering,\n    useStaticRendering\n} from \"mobx-react-lite\"\n\nexport { observer } from \"./observer\"\n\nexport { Provider, MobXProviderContext } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\n"],"names":["symbolId","createdSymbols","newSymbol","name","Symbol","symbol","createSymbol","shallowEqual","objA","objB","is","keysA","Object","keys","keysB","length","let","i","hasOwnProperty","call","x","y","const","hoistBlackList","$$typeof","render","compare","type","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","propTypes","setHiddenProp","target","prop","value","defineProperty","enumerable","configurable","writable","mobxMixins","mobxPatchedDefinition","wrapper","realMethod","locks","retVal","apply","this","args","methods","forEach","mx","wrapFunction","patch","methodName","mixinMethod","methodMixins","getMixins","indexOf","push","oldDefinition","getOwnPropertyDescriptor","newDefinition","createDefinition","originalMethod","wrappedFunc","get","set","undefined","mobxAdminProperty","$mobx","mobxIsUnmounted","skipRenderKey","isForcingUpdateKey","observerSCU","nextProps","nextState","isUsingStaticRendering","console","warn","state","props","makeObservableProp","propName","valueHolderKey","atomHolderKey","getAtom","createAtom","reportObserved","v","reportChanged","hasSymbol","for","ReactForwardRefSymbol","forwardRef","ReactMemoSymbol","memo","observer","componentClass","isMobxInjector","Error","baseRender","React","Observer","arguments","prototype","isReactClass","isPrototypeOf","Component","componentWillReact","__proto__","PureComponent","shouldComponentUpdate","initialName","displayName","constructor","bind","isRenderingPending","reaction","Reaction","hasError","forceUpdate","dispose","reactiveRender","exception","rendering","track","_allowStateChanges","e","reactComponent","makeClassComponentObserver","observerLite","MobXProviderContext","createContext","Provider","ref","parentValue","useContext","useRef","stores","current","process","env","NODE_ENV","children","createStoreInjector","grabStoresFn","component","injectNames","makeReactive","base","protoProps","Injector","newProps","context","assign","createElement","getOwnPropertyNames","getPrototypeOf","key","wrappedComponent","componentName","getInjectName","protoStoreKey","instStoreKey","runDisposersOnWillUnmount","propKeyOrFunction","Array","isArray","map","f","createChainableTypeChecker","validate","checkType","isRequired","location","propFullName","untracked","rest","chainedCheckType","getPropType","propValue","propType","RegExp","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","Date","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","error","PropTypes","observable","rdBatched","configure","reactionScheduler","storeNames","baseStores","storeName","grabStoresByName","join","disposeOnUnmount","propertyKeyOrFunction","fn","c","c2","componentWasAlreadyModified"],"mappings":"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"}